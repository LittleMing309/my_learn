笔记
=============================================================
垃圾回收
var arr = [];

传统语言:c
arr = malloc(1024);
...
..
.
...
.
free(arr);

============================================
内存泄露 		非常严重，很常见

垃圾回收机制 	帮你回收垃圾

生命周期
1.局部 		当函数结束时，函数中的局部变量回收
2.全局 		不会消失。当页面关闭消失
3.闭包 		如果函数里面的还能用，局部变量就不会消失
			如果函数里面的还能用，所有的局部变量就不会消失
			如果函数里面的还能用，整条作用域链上的所有局部变量就不会消失

function show(){
	var a = 12;
}

执行前  			
show      执行中 		声明a
执行后 					把a干掉


var a = 12;
function show(){
	alert(a);
}

show();


function show(){
	var a = 12;
	document.onclick=function(){
		alert(a);
	};
}
show();

a不会消失
document.onclick = null;


function show(){
	var a = 12;
	var b = 5;
	document.onclick=function(){
		alert(a);
	};
}
show();
======================
b不会消失

=======================================
1.耗费性能
2.为了万无一失


var a = 12;
function aaa(){
	var b = 5;
	function bbb(){
		var c = 3;
		document.onclick=function(){
			alert(a);
		};
	}
	bbb();
}
aaa();

作用域链:先在自己里面找，找不到，找父级，再找父级。。。。全局

=============================================================
递归: 把大事分成小事

10块钱1只，买了一对，一公一母
1.兔子不会死
2.兔子不用吃东西
3.兔子可以近亲结婚
4.3个月长大，只要长大就下一对小兔子，以后每个月都下一对。

1 	2 	3 	4 	5 	6 	7 	8 	9 	10 	11 	12
1 	1	2 	3 	5 	8 	13 	21 	34 	55 	89 	144

程序算
f(n-1)+f(n-2)

12 	144 			2880
24 	46368			927360
36 	14930352		298607040		
48 	4807526976		96150539520	
60	1548008755920	30960175118400

递归，效率非常高。

斐波那契数列 	兔子数列 
斐波那契 	

==========================================
异常 		程序与控制不了

try{
	放可能出问题的代码
}catch(e){
	补救的代码
}

try。。。catch 	应急用的。

================================================
严格模式
1.this的问题
2.禁止在if，for，switch ，while，do..while,forin中声明函数
3.禁用了with
4.禁止了不加var声明全局变量

====================================================
优化

1.稳定性
2.扩展性
3.性能

对于前端来说，性能并不太重要。
1s  		0.000000001s


性能:
1.网络性能
	借助工具:
		1.浏览器自带network 		想玩好，需要经验
		2.YSlow 	雅虎出的		简单，学习
			firefox

			http://yslow.org/mobile


1.合并文件
 	100文件 	连接一百次，请求一百次，等待一百次，接收一百次
 	1文件 		连接1次，请求1次，等待1次，接收1次。

 	文件合并之后一定比没合并之前小。

 	结论:css，js，要合并，图片合并

 	减少http请求，降低服务器压力，缩小文件体积。

2.代码压缩
 	减少文件体积


3.图片延迟加载
		省流量

4.gzip 		服务器压缩

5.js阻塞加载
	js在加载的时候，会阻塞。其他的都用不了

	解决方案。把script标签放到下面


	css放在上面

	结论：js放在下面，css放在上面。

6.CDN		Content Delivery Network

	更稳定，更快速，帮组分担，安全





2.执行性能
1.少用全局
2.不用的东西就干掉
3.尽量用系统提供的东西
4.尽量使用正则操作字符串

有用的
1.减少DOM操作
		运动：看不见的运动，就让它停掉

2.循环
for(var i=0;i<aBtn.length;i++){ 	//慢
	
}

var len = aBtn.length;				//快
for(var i=0;i<len;i++){
	
}


3.关于全局，局部，属性

	性能由高-》低:
		局部-》全局-》属性

		对象身上有一堆属性。
		属性越多性能越低。

4.定时器不用就关掉。


用户体验方面
运动 		30
	
	帧频  	30 	低帧频 		1000/30		33

			16 	高帧频 		1000/16 	60

以后的运动不要用30，要用16 


没用的
var str = '';
str+='abc';
str+='bcd';
str+='cde';
str = 'abcbcdcde';

var arr = ['abc','bcd','cde'];
str = arr.join('');

======================================================
面向对象————不知内部原理，但是不影响你使用。
oDate.getFullYear();
var arr = [1,2,3];

对象————想象成一个盒子，有一些功能。你可以使用，但是你不知道原理，你也不需要原理。

==================================================
程序猿要求特别高。

面向对象——为了让程序员更多，让程序员写程序跟简单。


==================================================
对象由什么构成？
属性和方法

arr.length
oBtn.value

arr.push()
arr.shift();


属性：属性是属于某个对象的，变量是自由的。
		其实变量就是属性，属性就是变量。只是叫法不同



方法：方法是属于某个对象的，函数时自由的。
		起始方法就是函数，函数就是方法。只是叫法不同



数组 		本身有属性，本身有方法
1.覆盖
2.性能不好。

期望有一个空的对象供我们使用!
new Object(); 		几乎是空的。

工厂
1.原料
2.加工
3.卖



问题：
0.没有new
1.方法本身不相等

new是给函数加的。


new 只有两个作用：
1.自动帮你   this = new Object();
2.自动帮你 	 return this;


CreatePerson  		类
p1 					对象
p2 					对象

方法要给类加
属性要给对象加

加方法给类的原型加
原型
类.prototype.xx=function(){
	
};

******
属性给对象加
方法给类的原型加

=====================================================
this有优先级

高 	
	new 			object
	定时器 			window
	事件 			触发事件的元素
	方法 			对象本身
	其他 			window||undefined
低


1.this优先级
2.听最后一次调用
3.只作用域1层。

=====================================================
this应用

面向过程 		函数+函数+函数
面向对象 		对象+对象+对象


选项卡

所有的变量都变成属性
所有的函数都变成方法

拖拽


用面向对象思想写东西：
1.把所有变量变成属性
2.把所有函数变成方法
3.注意this


面向对象

